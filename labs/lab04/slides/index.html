<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Lab 4: Javascript II</title>
	<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="gold" /><text x="17" y="85" style="font: 600 60px/1 system-ui">JS</text></svg>' />
	<link href="talk.css" rel="stylesheet" />
	<script src="./talk.js" type="module"></script>
</head>
<body class="language-markup no-media" data-markdown-elements="details.notes, .md, .md-children > *">

<header id="intro" class="slide dont-resize">
	<h1>
		<div class="label">Lab 4</div>
		Javascript II
	</h1>
	<small>
		DSC 106: Data Visualization
		<!-- &bull; Slides by <a href="http://lea.verou.me">Lea Verou</a> -->
	</small>
</header>
<!-- Translate python to javascript and simple javascript examples -->
<!-- <article class="slide columns force-1" id="npm">
	<header>
		<h1>What is <img src="images/npm-logo.svg" alt="npm">?</h1>
		<p class="subtitle">A <em>package manager</em> for JS</p>
	</header>
	<video src="videos/npm-install.mp4" loop autoplay muted></video>
	<details class="notes">
		A package manager is a tool that automates the process of installing, updating, configuring, and removing software.
		If you‚Äôve written Python, you have likely used `pip`, its own package manager.
		You may have used package managers to install software in your operating system,
		such as`apt-get` or `brew`.
		They are command-line tools that allow you to install software from a central repository by simply referencing its name (and optionally a specific version).

		NPM stands for "Node Package Manager".
		It was originally created for Node.js, a JavaScript runtime that allows you to run JavaScript on the server.
		These days, NPM is used for much more than just Node.js, and is the most popular package manager for JavaScript.
		Most front-end developers use NPM to manage build tools and dependencies for their projects.

		Most NPM packages correspond to GitHub repos.
		When you install a package, NPM will download the package from the _NPM registry_ and install it in a directory called `node_modules`.
	</details>
</article> -->

<!-- <article class="slide columns force force-1">
	<h1>Anyone can publish a package!</h1>
	<img src="images/npm-anyone.png" alt="" class="browser">
</article>

<article class="slide md" id="npm-101" data-type="Cheatsheet">
	# npm 101

	- `package.json` A file containing metadata about a project
	- `node_modules/` A directory containing all the dependencies of a project
	- `npm install` Installs all dependencies listed in `package.json`
	- `npm install PACKAGE_NAME` Installs a package and adds it to `package.json`
	- `npm create PACKAGE_NAME` Create a new prpject, using another package as a template
	- `npm run SCRIPT_NAME` Runs a script defined in `package.json` (e.g. `build`, `dev`, etc.)
</article> -->

<!-- <article class="slide">
	<h1>Why use a JS Framework?</h1>
	<ol>
		<li>
			Developer Experience
			<ul class="delayed pros">
				<li>Declarative syntax</li>
				<li>Reactivity</li>
				<li>Modularity</li>
				<li>Convenience</li>
			</ul>
		</li>
	</ol>

	<details class="notes">
		There are many, *many* JS frameworks out there.
		The only reason to use a JS framework is development convenience.
		In theory, you could write everything in vanilla JS (as JS-without-frameworks is often called), but it would be a lot more work.
		However, development convenience can indirectly benefit end-users as well,
		because if you can develop faster, you can iterate faster, and deliver more features and bugfixes in the same amount of time.

		But how do JS frameworks provide development convenience?
		On a high level, in two ways:
		- **Declarativeness and reactivity**:
		Remember how we discussed that HTML and CSS are declarative and reactive, but JS is not?
		In CSS you declare what you want to happen, and it autoamtically takes care of the steps,
		whereas in JS, you have to specify every step.
		In CSS when a value changes (e.g. a CSS variable), everything that depends on it is automatically updated.
		JS frameworks expose a syntax that makes JS *declarative* and *reactive* as well.
		- **Modularity**:
		JS frameworks give us easier ways to break up the code of a large website or app into small, independent pieces that can be managed separately.
		This is achieved in many ways, such as components, data binding, etc.
	</details>
</article> -->

<!-- <article class="slide columns force-1" id="templating" data-credits="Wikipedia">
	<h1>Data binding</h1>
	<img src="images/templating.png" alt="">
</article>

<article class="slide columns force-3 code-labels" id="build-process">
	<h1>What is a build process?</h1>
	<section>
		<h2>index.md</h2>
		<pre class="language-markdown"><code>
			---
			title: Build Tools
			---

			# Build Process

			A build process reads *input files*
			and coverts them into *output files*.
		</code></pre>
	</section>
	<div class="arrow-right"></div>
	<section>
		<h2>index.html</h2>
		<pre class="language-html"><code>
			&lt;!DOCTYPE html>
			&lt;html>
			&lt;head>
				&lt;title>Build Tools&lt;/title>
			&lt;/head>
			&lt;body>
				&lt;h1>Build Process&lt;/h1>
				&lt;p>A build process reads &lt;em>input files&lt;/em>
				and coverts them into &lt;em>output files&lt;/em>.
			&lt;/body>
			&lt;/html>
		</code></pre>
	</section>
	<details class="notes">
		A build process is basically a compilation step that allows us to write code in a language other than those that the browser supports natively.
		It can do dramatic things like convert (*transpile*) a language that the browser doesn‚Äôt understand at all (e.g. TypeScript or CoffeeScript) to JavaScript,
		or lighter things like convert a language feature that the browser doesn‚Äôt understand yet (e.g. CSS nesting) to a version that it does understand.

		By convention, we run a website‚Äôs build process by running `npm run build`,
		which looks for a `build` key in the `scripts` part of `package.json`.
	</details>
</article> 

<article class="slide columns" id="modern-web-apps">
	<h1>Modern web apps</h1>
	<img src="images/components-1.png" alt="">
</article>

<article class="slide" id="also-modern-web-apps">
	<h1>Also modern web apps</h1>
</article>
-->
<!-- <article class="slide">
	<h1 class="md">HTML: `&lt;h1>` `&lt;ul>` `&lt;p>`</h1>
</article> -->

<article class="slide" id="dogfood">
	<h1 class="balance-lines">These labs dogfood</h1>

	<p>All slides and lab materials using open web technologies.</p>
	<ul>
		<li>Slides posted right after lab</li>
		<li>Explore both content and implementation!</li>
	</ul>
	<details class="notes">
		We are using inspire.js for these slides!
	</details>
</article>

<section id="web">
	<header class="slide">
		<h1>How does the Web work?</h1>
	</header>

	<article class="slide">
		<header>
			<h1>The URL</h1>
			<p>The Web‚Äôs primary innovation</p>
		</header>
		<code class="syntax-breakdown language-url target-width-80" data-tooltip="bottom" style="--line-length: 3em">
			<span title="Protocol">https:</span>//
			<span title="Host">dsc106.com</span>
			<span title="Path to resource">/labs/1/hello.html</span>
		</code>
		<details class="notes">
			What many people don‚Äôt realize is that the Web was primarily a usability innovation, and the URL was the centerpiece of that.
			Before the Web, we still had computers connected to the internet, that we could access remotely.
			However, accessing resources involved several steps: connecting to the remote computer, navigating to the directory where the resource was, and then downloading it.
			The URL encoded all information to retrieve a resource into a single string that could be copied, pasted, and even clicked.

			Let‚Äôs take a look at an example URL to a file on our course website.
			It starts with the protocol, which is the language that the client and server will use to communicate.
			This is usually `https` nowadays, which is a secure version of the `http` protocol.

			Then, we have the host or authority, which is the computer that hosts the resource we want to access.
			Finally, we have the path to the resource, which is the location of the resource on the host.
		</details>
	</article>

	<article class="slide dont-resize" id="local-urls" style="--line-length: 3em; --tooltip-orientation: vertical;" data-type="Activity">
		<header>
			<h1>Local URLs <span class="chip">Part 1</span></h1>
			<p>The <code>file:</code> protocol</p>
		</header>
		<code class="syntax-breakdown language-url target-width-80" style="--char-aspect-ratio: 2.215">
			<span title="Protocol">file:</span>//
			<span title="Path to resource from filesystem root">/Users/giorgianicolaou/Documents/dsc106/labs/1/hello.html</span>
		</code>
		<details class="notes">
			Let‚Äôs look at a different example.

			Download the file `hello.html` from the course website and double click it to get it to open in your browser.
			You will probably see something similar to this.
			This allows you to open files from your local filesystem and view them in a browser.
			Note that there is no host (since `file:` protocol URLs always refer to your own computer)
			and that the path starts from the root of your filesystem.
			This means that opening a malicious website this way could potentially access any file on your computer,
			which is why the `file:` protocol is very locked down today as it‚Äôs considered unsafe.

			We will use the `file:` protocol for now,
			but in future labs, we will learn how to run a _local server_ to view our files, which is a lot more flexible.

			<!-- Instead of the `file:` protocol, when developing websites locally, we usually run one or more *local servers*, which we can access via the special domain name `localhost`.
			To allow the same domain name to be used as the host for multiple websites, we have the concept of *ports*.
			Every URL has a port, but it‚Äôs usually omitted when it‚Äôs the default port for the protocol (80 for HTTP and 443 for HTTPS).

			Note that now the path starts from the root of the website, not the root of the filesystem.
			This is because I‚Äôm running the local server at the root of the website.
			This also means that files outside the root of the website are not accessible, which is a security feature. -->

			Read more:
			- ["What is a URL?" on MDN](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL)
		</details>
	</article>

	<article class="slide" id="relative-paths">
		<h1>Understanding Relative Paths</h1>
	
		<form>
			<label>
				Current File:
				<input type="text" name="current" value="/labs/lab04/slides/index.html" readonly>
			</label>
	
			<label>
				üîπ Path: <code>./hello.html</code><br>
				<strong>Resolves to:</strong>
				<input type="text" name="dot-path" value="/labs/lab04/slides/hello.html" readonly>
			</label>
	
			<label>
				üîπ Path: <code>../hello.html</code><br>
				<strong>Resolves to:</strong>
				<input type="text" name="dotdot-path" value="/labs/lab04/hello.html" readonly>
			</label>
	
			<label>
				üîπ Path: <code>../../hello.html</code><br>
				<strong>Resolves to:</strong>
				<input type="text" name="up-two-path" value="/labs/hello.html" readonly>
			</label>
	
			<label>
				üîπ Path: <code>/hello.html</code><br>
				<strong>Resolves to:</strong>
				<input type="text" name="root-path" value="https://dsc106.com/hello.html" readonly>
			</label>
		</form>
	
		<details class="notes">
			This slide shows how different relative path syntaxes work:
			- `./` ‚Üí current directory
			- `../` ‚Üí up one directory
			- `/` ‚Üí root of the website
	
			These are interpreted relative to the **location of the current file**, not the server.
		</details>
	</article>
	

	<article class="slide">
		<h1>The Web: Open by design</h1>

		<video src="videos/devtools.mp4" class="max-size browser" data-url="https://en.wikipedia.org/wiki/Massachusetts_Institute_of_Technology" loop autoplay muted></video>

		<details class="notes">
			The Web was designed to be open: you can view the code of any website, and even modify it on the fly!

			There are two browser features for this:
			- _View Source_ shows you the HTML code of the page, as it was sent by the server.
			To use this you can right click on the page and select _View Source_, or press `Ctrl+Shift+U` or `Cmd+Shift+U`.
			- _Dev Tools_ allow you to inspect the current status of all code being used to create the page, and even modify it on the fly.
			You can also view all HTTP requests and responses, and even simulate different network conditions.
			Note that this requires reloading the page.

			To open dev tools:
			- On Mac: Press `Cmd+Shift+I`
			- On Windows: `F12` or `Ctrl+Shift+I` on Windows
			- From the menu bar: View ‚Üí Developer ‚Üí Developer Tools
			- In many browsers you can also right click anywhere on the page and select _Inspect Element_

			Note that this can be a double edged sword: while it can be very educational to look at how existing websites are built,
			there are many, *many* websites that are not following best practices, or do things in a suboptimal way.
			Often this is a result of their age, or the tradeoffs they had to make (e.g. performance or browser support over maintainability).
		</details>
	</article>
</section>

<section id="web-platform">
	<article class="slide columns code-labels">
		<h1>The Web Platform</h1>

		<section class="language-html">
			<h2>HTML</h2>
			<p>Structure</p>
			<pre><code>
				&lt;h1>Hello world!&lt;/h1>
				&lt;p>This is my
					&lt;em>first&lt;/em> web page! ü§Ø
				&lt;/p>
			</code></pre>
		</section>
		<section class="language-css">
			<h2>CSS</h2>
			<p>Presentation</p>
			<pre><code>
				body {
					font: 100%/1.5 system-ui;
				}

				h1 {
					color: deeppink;
					font-size: 300%;
				}
			</code></pre>
		</section>
		<section class="language-js">
			<h2>JS</h2>
			<p>Behavior</p>
			<pre><code>
				document.onclick = event => {
					alert(`You clicked at
					${event.x}, ${event.y}`);
				};
			</code></pre>
		</section>
		<details class="notes">
			The collection of technologies that we use to create websites and web applications is called [The Web Platform](https://en.wikipedia.org/wiki/Web_platform#:~:text=The%20Web%20platform%20is%20a,Task%20Force%2C%20and%20Ecma%20International).
			It consists of three main technologies: HTML, CSS, and JavaScript.

			- HTML is used to specify the structure of the content, for example headings, paragraphs, lists, etc.
			- CSS is used to specify how content *looks*, for example colors, fonts, spacing, layout, etc.
			CSS will be the focus of the next lab, so we will learn a lot more about it then.
			- Finally, JavaScript is used to specify how content *behaves*, for example what happens when you click a button, or when you scroll the page, as well as for automation.
			- Ideally, these should be designed to be as independent as possible (separation of concerns).
			[CSS Zen Garden](https://csszengarden.com/) was built to demonstrate this point by showing how the same HTML can be styled in completely different ways by different CSS files,
			and significantly contributed to CSS‚Äôs adoption at the time.

			You can view a web page with the HTML, CSS, and JS from this slide at [`labs/1/first.html`](../first.html)
		</details>
	</article>

	<article class="plain slide">
		<h1>Similarties & differences</h1>
		<ul>
			<li>HTML and CSS have simple <em>syntax</em> and large <em>vocabulary</em>, JS the opposite</li>
			<li>Error handling: HTML and CSS are <em>forgiving</em>, JS is <em>strict</em></li>
			<li>HTML and CSS are <a href="https://en.wikipedia.org/wiki/Declarative_programming">declarative</a>, JS is <a href="https://en.wikipedia.org/wiki/Imperative_programming">imperative</a></li>
		</ul>
	</article>

	<article class="slide columns code-labels">
		<h1>HTML at the root of it all</h1>
		<section class="language-html">
			<h2>CSS</h2>
			<pre class="no-code-label"><code>
				&lt;link rel="stylesheet" href="style.css" />
			</code></pre>
			<pre><code>
				&lt;style>
					h1 {
						color: deeppink;
					}
				&lt;/style>
			</code></pre>
		</section>
		<section class="language-html">
			<h2>JS</h2>
			<pre class="no-code-label"><code>
				&lt;script type="module" src="hello.js">&lt;/script>
			</code></pre>
			<pre><code>
				&lt;script type="module">
					alert("Hello world!");
				&lt;/script>
			</code></pre>
		</section>
		<details class="notes">
			- Every webpage consists of HTML. It is the HTML that includes all other langagues.
			- CSS and JS can be either linked from separate files or embedded in the HTML file itself.
			- Embedding them can be useful for prototyping, but it‚Äôs generally better to keep them separate so they can be used by multiple pages and cached separately.
			- Note that it is possible to have `&lt;script>` elements without `type="module"`, but we recommend you always use `type="module"` as it enables a few modern JS features and prevents certain errors.
		</details>
	</article>

	<article class="slide columns code-labels" id="subresources" data-steps="1">
		<h1>Each language imports subresources</h1>

		<section class="language-css">
			<h2>CSS</h2>
			<pre><code>
				@import url("colors.css");
			</code></pre>
			<div class="arrow-down"></div>
			<pre class="language-html"><code>
				&lt;style>
					@import url("style.css");
				&lt;/style>
			</code></pre>
		</section>
		<section class="language-js">
			<h2>JS</h2>
			<pre><code>
				import * as util from "utils.js";
			</code></pre>
			<div class="arrow-down"></div>
			<pre class="language-html"><code>
				&lt;script type="module">
					import "hello.js";
				&lt;/script>
			</code></pre>
		</section>
	</article>

	<article class="slide columns code-labels" id="error-handling">
		<h1>Error handling</h1>

		<section class="language-html delayed">
			<header>
				<h2>HTML is <span class="chip good">forgiving</span></h2>
				<p>It tries to <em>fix</em> your mistakes</p>
			</header>
			<pre><code>
				&lt;em>Emphasized
					&lt;strong>Both
				&lt;/em> Important&lt;/strong>
			</code></pre>
			<div class="arrow-down"></div>
			<pre><code>
				&lt;em>Emphasized
					&lt;strong>Both&lt;/strong>
				&lt;/em>
				&lt;strong>Important&lt;/strong>
			</code></pre>
		</section>
		<section class="language-css delayed">
			<header>
				<h2>CSS is <span class="chip good">forgiving</span></h2>
				<p>It <em>ignores</em> your mistakes</p>
			</header>
			<pre><code>
				h1 {
					color: slategray;
					foobar: yolo;
				}
			</code></pre>
			<div class="arrow-down"></div>
			<pre><code>
				h1 {
					color: slategray;
				}
			</code></pre>
		</section>
		<section class="language-js delayed">
			<header>
				<h2>JS is <span class="chip bad">strict</span></h2>
				<p>It <em>stops</em> at the first mistake</p>
			</header>
			<pre><code>
				alert("Hello world!"
			</code></pre>
			<div class="arrow-down"></div>
			<pre class="error no-code-label"><code>Uncaught SyntaxError: missing ) after argument list</code></pre>
		</section>

		<details class="notes">
			In fact, this forgiving nature of HTML and CSS is core to the Web‚Äôs success.
			Attepmpts to define a stricter version of HTML (XHTML) failed miserably.

			This is also one reason why it‚Äôs generally a bad idea if your webpage depends on JS for essential content.
		</details>
	</article>

	<article class="slide">
		<h1>Dev Tools & Errors</h1>
		<video src="videos/devtools-errors.mp4" class="max-size browser" data-url="https://vis-society.github.io/labs/1/errors.html" loop autoplay muted></video>
	</article>

	<article class="slide language-html" id="emmet-html-skeleton">
		<h1>Emmet‚Äôs HTML skeleton <kbd>!</kbd> <kbd>Tab</kbd></h1>
		<pre><code class="syntax-breakdown">
			<span title="HTML5+ Doctype = ‚ÄúThis is modern HTML‚Äù">&lt;!DOCTYPE html></span>
			<span title="Root element" data-tooltip="top">&lt;html <span title="Content language" data-tooltip="right">lang="en"</span>>
			<span title="Metadata about the page (not displayed)" style="--line-length: 3em; --offset: 1em;">&lt;head>
				<span xtitle="Character encoding" data-tooltip="right">&lt;meta charset="UTF-8"></span>
				<span xtitle="How to render on mobile" style="--line-length: 2em; offset: 1em;">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"></span>
				<span title="Page title shown in browser tab" data-tooltip="right">&lt;title>Document&lt;/title></span>
			&lt;/head></span>
			<span title="Visible page content goes here" data-tooltip="right">&lt;body>

			&lt;/body></span>
			&lt;/html></span>
		</code></pre>
		<details class="notes">
			You have seen in the lab 0 that Emmet creates a basic HTML page skeleton for you when you press `!` and then `Tab`.
			But what do all these elements do? Do we need them?

			- `&lt;!DOCTYPE html>` is the *document type declaration*, which tells the browser that this is a modern HTML document. It is not actually an HTML element.
			- `&lt;html>` is the root element of the document, and contains all other elements.
			- The `lang` attribute specifies the language of the content, which is useful for screen readers and other accessibility tools, as well as several web platform features (e.g. hyphenation).
			It‚Äôs available on every element, not just the root.
			- [`&lt;head>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head) contains metadata about the page, such as the character encoding, the page title, and more. It is not displayed on the page.
			- The [viewport meta tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag) controls parameters for mobile rendering
			and also tells the browser not to apply the kinds of heuristics it uses for pages not optimized for mobile.
			- `&lt;title>` is the title of the page, which is shown in the browser tab. It is the only element that is actually required
			(corollary: `&lt;DOCTYPE html>&lt;title>Hey&lt;/title>` is a [valid](https://validator.w3.org/nu/#textarea) HTML document).
			- `&lt;body>` contains the visible content of the page.
			- While technically `&lt;html>`, `&lt;head>`, and `&lt;body>` are optional, they are automatically inserted by the browser if not specified
			(as you can verify yourself by inspecting [`hello.html`](../hello.html)).
		</details>
	</article>

	<article class="slide columns language-html elements" id="html-elements" data-type="Cheatsheet">
		<h1>HTML elements</h1>
		<section class="md">
			## Markup / Content
			- Headings (`&lt;h1>`, `&lt;h2>`, `&lt;h3>`, `&lt;h4>`, `&lt;h5>`, `&lt;h6>`)
			- Paragraphs (`&lt;p>`)
			- Lists (`&lt;ul>`, `&lt;ol>`, `&lt;li>`, etc.)
			- Tables (`&lt;table>`, `&lt;thead>`, `&lt;tr>`, `&lt;td>`, etc.)
			- Sectioning (`&lt;header>`, `&lt;footer>`, `&lt;main>`, `&lt;section>`, `&lt;article>`, `&lt;nav>` etc.)
			- Inline markup (`&lt;em>`, `&lt;strong>`, `&lt;code>` etc.)
			- Figures (`&lt;figure>`, `&lt;figcaption>`)
		</section>
		<section class="md">
			## Interactive
			- Forms (`&lt;form>`, `&lt;input>`, `&lt;textarea>`, `&lt;button>`, etc.)
			- Links (`&lt;a>`)
			- Progressive disclosure (`&lt;details>`, `&lt;dialog>`)

			## Resources / Embedding
			- Multimedia (`&lt;img>`, `&lt;video>`, `&lt;audio>`, `&lt;svg>`, etc.)
			- External resources (`&lt;link>`, `&lt;script>`, etc.)
			- Embeds (`&lt;iframe>`, `&lt;object>`, etc.)
		</section>
		<details class="notes">
			- The purpose of markup elements is to mark up content, usually by assigning semantics.
			- Interactive elements on the other hand provide functionality.

			[Full list of HTML elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element)
		</details>
	</article>
</section>

<article class="slide columns force" data-credits="https://www.componentdriven.org/" id="cdd">
	<h1>Component-driven development</h1>
	<img src="images/cdd.png" alt="">
</article>

<article class="slide">
	<h1>Traditional Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/traditional-architecture-1.png" alt="">
		<img src="images/traditional-architecture-2.png" class="delayed" alt="">
		<img src="images/traditional-architecture-3.png" class="delayed" alt="">
	</div>
</article>

<!-- <article class="slide" id="cba">
	<h1>Component-based Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/cb-architecture-1.png" alt="">
		<img src="images/cb-architecture-2.png" class="delayed" alt="">
		<img src="images/cb-architecture-3.png" class="delayed" alt="">
		<img src="images/cb-architecture-4.png" class="delayed" alt="">
	</div>
</article>

<article class="slide" id="cba">
	<h1>Component-based Architecture</h1>
	<div class="frame-by-frame">
		<img src="images/cb-architecture-1a.png" alt="">
		<img src="images/cb-architecture-2a.png" class="delayed" alt="">
		<img src="images/cb-architecture-3a.png" class="delayed" alt="">
		<img src="images/cb-architecture-4a.png" class="delayed" alt="">
		<img src="images/cb-architecture-4.png" class="delayed" alt="">
	</div> -->
</article>

<article class="slide columns force-1">
	<img src="images/soc-components.png" alt="">
	<details class="notes">
		Components give us a *different* separation of concerns than what we have seen so far
		(and arguably more pragmatic and scalable).
	</details>
</article>

<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Basic Example Structure in JavaScript Modules</h1>
    
    <pre><code>
        <span class="delayed">üìÇ File Structure:
        index.html
        main.js
        modules/
            canvas.js
            square.js</span>

        <span class="delayed" data-index="2">üìå canvas.js ‚Äî Handles Canvas Setup
        function create(parent, width, height, id) {
            let wrapper = document.createElement("div");
            wrapper.id = id;
            let canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            wrapper.appendChild(canvas);
            parent.appendChild(wrapper);
            return { context: canvas.getContext("2d"), id };
        }

        function createReportList(wrapperId) {
            let list = document.createElement("ul");
            document.getElementById(wrapperId).appendChild(list);
            return list.id;
        }</span>

        <span class="delayed" data-index="3">üìå square.js ‚Äî Handles Square Operations
        const name = "square";

        function draw(context, x, y, size, color) {
            context.fillStyle = color;
            context.fillRect(x, y, size, size);
            return { size, x, y, color };
        }

        function reportArea(listId, length) {
            let list = document.getElementById(listId);
            let item = document.createElement("li");
            item.textContent = `Square area: ${length * length}`;
            list.appendChild(item);
        }

        function reportPerimeter(listId, length) {
            let list = document.getElementById(listId);
            let item = document.createElement("li");
            item.textContent = `Square perimeter: ${length * 4}`;
            list.appendChild(item);
        }</span>

        <span class="delayed" data-index="4">üìå main.js ‚Äî Bringing It All Together
        import { create, createReportList } from "./modules/canvas.js";
        import { draw, reportArea, reportPerimeter } from "./modules/square.js";

        const parent = document.body;
        const { context, id } = create(parent, 400, 400, "canvas-wrapper");
        const listId = createReportList(id);

        let square = draw(context, 50, 50, 100, "blue");
        reportArea(listId, square.size);
        reportPerimeter(listId, square.size);</span>
    </code></pre>

    <details class="notes">
        - `canvas.js` handles canvas setup and creates report lists.
        - `square.js` handles drawing squares and calculating their area/perimeter.
        - `main.js` brings it all together by importing functions and executing them.
        This modular approach improves maintainability, readability, and reusability.
    </details>
</article>

<!-- <article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Exporting Module Features in JavaScript</h1>
    
    <pre><code>
        <span class="delayed">üìå Exporting Individual Features
        export const name = "square";

        export function draw(ctx, length, x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, length, length);
            return { length, x, y, color };
        }</span>

        <span class="delayed" data-index="2">‚úÖ You can export:
        - Functions
        - Variables (var, let, const)
        - Classes (not inside a function)</span>

        <span class="delayed" data-index="3">‚ùå Exporting inside a function is not allowed
        function example() {
            export const invalid = "Can't export here"; ‚ùå This would throw an error
        }</span>

        <span class="delayed" data-index="4">üìå Exporting Multiple Features at Once
        function reportArea(length) {
            return `Square area: ${length * length}`;
        }

        function reportPerimeter(length) {
            return `Square perimeter: ${length * 4}`;
        }

        export { name, draw, reportArea, reportPerimeter };</span>
    </code></pre>

    <details class="notes">
        To use JavaScript modules, we **export** features from a module file using the `export` statement.
        - You can **export each feature individually** (`export function draw(...)`).
        - You can **export multiple features at once** using `{}` at the end of a file.
        - Exports must be **top-level** (not inside functions).
    </details>
</article> -->

<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Python vs JavaScript: Syntax Comparison</h1>

    <pre><code>
        <span class="delayed">üìå Function Definitions
        // JavaScript
        function greet(name) {
            return "Hello, " + name;
        }

        # Python
        def greet(name):
            return "Hello, " + name</span>

        <span class="delayed" data-index="2">üìå For Loops
        // JavaScript
        for (let i = 0; i < 5; i++) {
            console.log(i);
        }

        # Python
        for i in range(5):
            print(i)</span>

        <span class="delayed" data-index="3">üìå Conditionals
        // JavaScript
        if (x > 10) {
            console.log("Large");
        } else {
            console.log("Small");
        }

        # Python
        if x > 10:
            print("Large")
        else:
            print("Small")</span>
    </code></pre>

    <details class="notes">
        This slide compares core syntax between Python and JavaScript for:
        - **Function definitions**
        - **For loops**
        - **Conditional logic**
        These are useful to understand the **structural similarities** and **syntax differences** when switching between the two languages.
    </details>
</article>


<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Python vs JavaScript: More Syntax Examples</h1>

    <pre><code>
        <span class="delayed">üìå Importing Modules
        // JavaScript
        import fs from 'fs';

        # Python
        import os</span>

        <span class="delayed" data-index="2">üìå Variable Declarations
        // JavaScript
        let count = 5;
        const name = "Alice";

        # Python
        count = 5
        name = "Alice"</span>

        <span class="delayed" data-index="3">üìå Lists vs Arrays
        // JavaScript
        let fruits = ["apple", "banana", "cherry"];
        fruits.push("date");

        # Python
        fruits = ["apple", "banana", "cherry"]
        fruits.append("date")</span>
    </code></pre>

    <details class="notes">
        - Both languages use a **list-like structure**: arrays in JavaScript, lists in Python.
        - Operations like `push()` in JavaScript and `append()` in Python are analogous.
        - Understanding these similarities helps when porting or comparing logic across the two.
    </details>
</article>


<!-- <article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Creating a Module Object in JavaScript</h1>

    <pre><code>
        <span class="delayed">üìå Importing Everything as a Module Object
        import * as Module from "./modules/module.js";</span>

        <span class="delayed" data-index="2">‚úÖ Now, you can access functions as object properties
        Module.function1();
        Module.function2();</span>

        <span class="delayed" data-index="3">üìå Applying This to a Real Example
        Exports in each module remain simple
        export { name, draw, reportArea, reportPerimeter };</span>

        <span class="delayed" data-index="4">üìå Importing Multiple Modules as Objects
        import * as Canvas from "./modules/canvas.js";
        import * as Square from "./modules/square.js";
        import * as Circle from "./modules/circle.js";
        import * as Triangle from "./modules/triangle.js";</span>

        <span class="delayed" data-index="5">‚úÖ Now, use the module's functions under its namespace
        const square1 = Square.draw(myCanvas.ctx, 50, 50, 100, "blue");
        Square.reportArea(square1.length, reportList);
        Square.reportPerimeter(square1.length, reportList);</span>
    </code></pre>

    <details class="notes">
        Instead of importing multiple functions individually, we can **import an entire module as an object**.
        - This keeps our imports **cleaner** and **more structured**.
        - Instead of calling `draw()`, we now use `Square.draw()`‚Äîthis **prevents name conflicts**.
        - This approach is useful when handling **multiple related modules** in a project.
    </details>
</article> -->


<!-- <article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Modules and Classes in JavaScript</h1>

    <pre><code>
        <span class="delayed">üìå Defining a Class in a Module (square.js)
        class Square {
            constructor(ctx, listId, length, x, y, color) {
                this.ctx = ctx;
                this.listId = listId;
                this.length = length;
                this.x = x;
                this.y = y;
                this.color = color;
            }

            draw() {
                this.ctx.fillStyle = this.color;
                this.ctx.fillRect(this.x, this.y, this.length, this.length);
            }

            reportArea() {
                console.log(`Square area: ${this.length * this.length}`);
            }

            reportPerimeter() {
                console.log(`Square perimeter: ${this.length * 4}`);
            }
        }</span>

        <span class="delayed" data-index="2">üìå Exporting the Class
        export { Square };</span>

        <span class="delayed" data-index="3">üìå Importing the Class in main.js
        import { Square } from "./modules/square.js";</span>

        <span class="delayed" data-index="4">‚úÖ Using the Class to Create and Draw a Square
        const square1 = new Square(myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue");
        square1.draw();
        square1.reportArea();
        square1.reportPerimeter();</span>
    </code></pre>

    <details class="notes">
        Instead of exporting individual functions, we can **use ES6 classes** inside modules.
        - This approach is useful when working in an **object-oriented** style.
        - The `Square` class encapsulates **both state and behavior** related to a square.
        - By importing `Square`, we can create multiple instances, making our code **more reusable**.
    </details>
</article>


<article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Aggregating Modules in JavaScript</h1>

    <pre><code>
        <span class="delayed">üìå Aggregating Modules Using Export
        export * from "x.js";
        export { name } from "x.js";</span>

        <span class="delayed" data-index="2">üìå Example: Module Structure
        modules/
            canvas.js
            shapes.js
            shapes/
                circle.js
                square.js
                triangle.js</span>

        <span class="delayed" data-index="3">üìå Exporting from Individual Submodules
        In square.js, circle.js, and triangle.js:
        export { Square };
        export { Circle };
        export { Triangle };</span>

        <span class="delayed" data-index="4">üìå Aggregating Modules in shapes.js
        export { Square } from "./shapes/square.js";
        export { Triangle } from "./shapes/triangle.js";
        export { Circle } from "./shapes/circle.js";</span>

        <span class="delayed" data-index="5">‚úÖ Using the Aggregated Module in main.js
        Before (multiple imports)
        import { Square } from "./modules/square.js";
        import { Circle } from "./modules/circle.js";
        import { Triangle } from "./modules/triangle.js";

        After (single import)
        import { Square, Circle, Triangle } from "./modules/shapes.js";</span>
    </code></pre>

    <details class="notes">
        Instead of importing multiple submodules separately, we can **aggregate them** into a single parent module.
        - `shapes.js` acts as a **wrapper** that re-exports everything from `square.js`, `circle.js`, and `triangle.js`.
        - This keeps our **imports cleaner** and **reduces complexity**.
        - The exports in `shapes.js` are **redirects** and cannot contain additional logic.
    </details>
</article> -->

<!-- <article class="slide columns force-2 dont-resize language-js code-labels">
    <h1>Dynamic Module Loading in JavaScript</h1>

    <pre><code>
        <span class="delayed">üìå Dynamically Importing a Module
        import("./modules/myModule.js").then((module) => {
            Do something with the module.
        });</span>

        <span class="delayed" data-index="2">‚úÖ Dynamic Imports are Useful for:
        - Loading modules only when needed (performance boost)
        - Keeping initial script lightweight
        - Importing in non-module scripts
        - Avoiding unnecessary network requests</span>

        <span class="delayed" data-index="3">üìå Example: Loading Modules on Button Click
        Get reference to button
        const squareBtn = document.querySelector(".square");

        Attach event listener for dynamic import
        squareBtn.addEventListener("click", () => {
            import("./modules/square.js").then((Module) => {
                const square1 = new Module.Square(
                    myCanvas.ctx, myCanvas.listId, 50, 50, 100, "blue"
                );
                square1.draw();
                square1.reportArea();
                square1.reportPerimeter();
            });
        });</span>

        <span class="delayed" data-index="4">‚úÖ Why Use Dynamic Imports?
        - Modules are only loaded when needed (e.g., button click)
        - Reduces initial load time of the webpage
        - Prevents loading unused code</span>
    </code></pre>

    <details class="notes">
        Dynamic module loading allows JavaScript to **import modules on demand**, improving performance by **loading only what is needed**.
        - The `import()` function **returns a Promise** that resolves with a module object.
        - Dynamic imports **work even in non-module scripts**, unlike static `import` statements.
        - This technique is useful for **lazy loading features**, **reducing network requests**, and **keeping code modular**.
    </details>
</article> -->


<!-- <article class="slide columns force dont-resize code-labels delayed-last" id="component-io">
	<h1>
		<span class="label">Components</span>
		Inputs and outputs
	</h1>

	<div>
		<pre class="syntax-breakdown language-jsx svelte no-trim"><code>
			&lt;ColorPicker <span title="Prop">format="oklch"</span>
				   <span title="Same as allowAlpha={true}">allowAlpha</span>
				   <span title="Map component data to context data" data-index="2">bind:color={ themeColor }</span>
				   <span title="Run saveThemeColor() when component fires a close event" data-index="2">on:close={ saveThemeColor }</span>>
				<span title="Component contents is is also an input" data-index="1">Theme color</span>
			&lt;/ColorPicker>
		</code></pre>

		<div class="browser">
			<color-swatch value="hsl(335 100% 50%)">Theme color</color-swatch>
		</div>
	</div>
	<img src="images/component-io.png" alt="">

	<details class="notes">
		Components are to UI what functions are to code.
		They have inputs, called *props*.
		Props look like HTML attributes, but can actually contain JS objects, arrays, etc.
		There is also another input: their contents.
		They are used to provide data and to parameterize the component.

		Often the only output of components is the UI they render.
		However, they can also have outputs, passed via *events*.
	</details>
</article> -->


<!-- 
<section>
	<header class="slide">
		<h1>Svelte (and SvelteKit)</h1>
	</header>

	<article class="slide">
		<h1>Why Svelte?</h1>

		<ul class="pros">
			<li>Performance</li>
			<li>Less client-side JS</li>
			<li>Easier syntax</li>
		</ul>
	</article>

	<article class="slide code-labels columns">
		<h1>Anatomy of a Svelte component</h1>
		<pre class="language-html svelte" style="--label: 'Component.svelte'"><code>
			&lt;script>
				// logic goes here
			&lt;/script>

			&lt;!-- HTML (zero or more elements) goes here

			&lt;style>
				/* Scoped CSS goes here */
			&lt;/style>
		</code></pre>
	</article>

	<article class="slide code-labels columns">
		<h1>Example Svelte component</h1>
		<section>
			<h2>Definition</h2>
			<pre class="language-html svelte" style="--label: 'Slider.svelte'"><code>
				&lt;script>
					// Define a prop "value"
					export let value = 50;
				&lt;/script>

				&lt;input type=range bind:value={value}>
				&lt;span>{ value }&lt;/span>

				&lt;style>
					span {
						display: inline-block;
						padding: 0 .4em;
						border-radius: .3em;
						background: oklch(95% 2% 200);
					}
				&lt;/style>
			</code></pre>
		</section>
		<section class="delayed">
			<h2>Usage</h2>
			<pre class="language-html svelte"><code>
				&LT;script>
					import Slider from './Slider.svelte';

					let myValue = 3;
				&LT;/script>

				&LT;Slider value={myValue}>&LT;/Slider>
			</code></pre>
			<div class="arrow-down"></div>
			<img src="images/slider.gif" alt="" class="browser" data-url="https://svelte.dev/repl/3ebeaec8826943e3a9deee0a1f0aedd2?version=4.2.12">
		</section>
		<details class="notes">
			[Live demo](https://svelte.dev/repl/3ebeaec8826943e3a9deee0a1f0aedd2?version=4.2.12)
		</details>
	</article>
</section>
 -->
<section>
	<article class="slide columns force-1">
		<h1>Reactivity</h1>
		<img src="images/spreadsheet.gif" alt="">
		<details class="notes">
			If you‚Äôve used a spreadsheet, you already know what reactivity is.
			The core idea of reactivity is that when a value changes, all dependent values are updated automatically.
		</details>
	</article>

	<article class="minimal demo slide code-labels" id="css-reactive">
		<h1>CSS is reactive</h1>
		<textarea class="language-html">
			<label>
				Hue:
				<input type="range" max="360" id="hue"
					   oninput="document.body.style.setProperty('--hue', this.value)">
			</label>
		</textarea>
		<textarea class="language-css">
			body {
				--hue: 180;
				background: oklch(97% 5% var(--hue));
				accent-color: oklch(65% 55% var(--hue));
				color: oklch(40% 20% var(--hue));
			}
		</textarea>
		<div class="demo-target"></div>
		<details class="notes">
			As we have already seen, CSS is reactive.
			For example, if we update a CSS variable via JS, everything that depends on it (including other variables) is updated automatically.
		</details>
	</article>

	<article class="slide columns language-html code-labels">
		<h1>JS is not reactive</h1>

		<section>
			<pre class="language-css"><code>
				a:hover {
					background: gold;
				}
			</code></pre>
			<pre><code>
				&lt;a href="#">Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>

		<section>
			<pre><code>
				&lt;a href="#"
				   onmouseover="this.style.background = 'gold';"
				>Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>

		<section>
			<pre><code>
				&lt;a href="#"
				   onmouseover="this.style.background = 'gold';"
				   onmouseout="this.style.background = '';"
				>Come here&lt;/a>
			</code></pre>
			<div class="arrow-down"></div>
			<iframe data-result class="browser"></iframe>
		</section>
		<details class="notes">
			Remember this? As a part of CSS pseudo-classes are reactive:
			not only does the background here become `gold` when the link is hovered,
			but it also returns to its previous state automatically, when the link stops being hovered.

			However, when we use JS to do the same thing, we have to manually set the background back to its original value ourselves.
		</details>
	</article>

	<article class="slide" id="reactivity-hard">
		<h1>Implenting reactivity is <em>hard</em></h1>
		<form>
			<input type="number" id="input_a" value="1" oninput="input_c.value = Number(input_a.value) + Number(input_b.value)"> +
			<input type="number" id="input_b" value="2" oninput="input_c.value = Number(input_a.value) + Number(input_b.value)"> =
			<input type="number" id="input_c" value="3" disabled>
		</form>
		<pre class="delayed"><code>
			&lt;input type="number" id="input_a"> +
			&lt;input type="number" id="input_b"> =
			&lt;input type="number" id="input_c" disabled>
		</code></pre>
	</article>

	<article class="slide columns force-2 dont-resize language-js code-labels">
		<h1>Reactivity with vanilla JS</h1>
		<pre><code>
			let a = 1, b = 2, c;
			<span class="delayed">input_a.value = a;
			input_b.value = b;</span>

			<span class="delayed">input_a.addEventListener("input", e => {
				a = Number(input_a.value);
				<span class="delayed" data-index="3">updateC();</span>
			});
			input_b.addEventListener("input", e => {
				b = Number(input_b.value);
				<span class="delayed" data-index="3">updateC();</span>
			});</span>

			<span class="delayed" data-index="2">function updateC() {
				c = a + b;
				input_c.value = c;
			}</span>

			<span class="delayed" data-index="4">updateC();</span>
		</code></pre>
		<details class="notes">
			The na√Æve approach to implementing reactivity ourselves is to add event listeners to everything that could possibly change,
			and update everything that may have been affected.
			This gets very complicated very fast, since we need to keep track of all the dependencies and update them all manually.
			[Live demo](https://codepen.io/leaverou/pen/OJGMyvQ)
		</details>
	</article>

	<article class="slide columns force-2 language-js code-labels dont-resize">
		<h1>Reactivity with vanilla JS <span class="chip">Part 2</span></h1>
		<pre><code>
			let a = 1, b = 2, c;
			input_a.value = a;
			input_b.value = b;

			<span class="delayed">function render() {
				a = Number(input_a.value);
				b = Number(input_b.value);
				c = a + b;
				input_c.value = c;
			}</span>

			<span class="delayed">render();</span>
			<span class="delayed collapse">input_a.addEventListener("input", render);
			input_b.addEventListener("input", render);</span>
			<span class="delayed">document.body.addEventListener("input", render);</span>
		</code></pre>
		<details class="notes">
			Because this is so tedious, what we end up doing instead is is bunching updates together
			and updating more things than we need to, often everything at once with a single function.
			Then, every time anything updates, we call that single function and update *everything*.
			With that approach, we could even listen to the `input` event on an ancestor, since it [*bubbles*](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling),
			a practice known as [event delegation](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_delegation).

			However, the more complex the app, the slower this practice becomes, as we are updating more than we need to.
			Also, this makees it impossible to implement *two-way binding*, i.e. also update the input when the value changes, not just the other way around.

			[Live demo](https://codepen.io/leaverou/pen/OJGMydE)
		</details>
	</article>

	<article class="slide columns force-1">
		<h1>Reactivity boils down to <em>recalculation</em></h1>
		<img src="images/abc-dependency-graph.png" alt="">

		<details class="notes">
			There is one clear theme in both previous examples:
			Implementing reactivity boils down to recalculating things.
			The tricky bit is knowing *what* to recalculate and *when*.

			The what is typically implemented with a [*dependency graph*](https://en.wikipedia.org/wiki/Dependency_graph).
			When a value changes, we recalculate everything that depends on it, and everything that depends on those, and so on.
			The when is typically implemented with *events* when it‚Äôs about updating data from user actions,
			and [accessors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors) and [proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) when it's about updating the UI from data.
		</details>
	</article>
</section>

<article class="slide columns code-labels" id="web-apis">
	<h1>What is a Web API?</h1>
	<section>
		<h2>Websites are for humans</h2>
		<img src="images/yelp-restaurant.jpg" alt="">
	</section>
	<section>
		<h2>APIs are for programs</h2>
		<pre class="language-json"><code>
			{
				"id": "cuisine-of-nepal-san-francisco",
				"name": "Cuisine of Nepal",
				"image_url": ...,
				"is_closed": false,
				"url": ...,
				"review_count": 303,
				"categories": [...],
				"rating": 4.5,
				"coordinates": {...},
				"transactions": [
					"delivery",
					"pickup",
					"restaurant_reservation"
				],
				"price": "$$",
				"location": {...},
				"phone": "+14156472222",
				"display_phone": "(415) 647-2222",
				"distance": 2502.5961202999997,
				"attributes": {
					"gender_neutral_restrooms": true
				},
				"data": {
					"reservation_openings": [
						"13:30",
						"13:45",
						"14:00"
					]
				}
			},
		</code></pre>
	</section>
</article>

<article class="slide language-js xcode-labels">
	<h1>Async values</h1>
	<pre><code>
		let response = await fetch("https://api.github.com/users/giorgianicolaou");
		let json = await response.json();
		// Do stuff with json
	</code></pre>
	<pre><code>
		fetch("https://api.github.com/users/giorgianicolaou")
			.then(response => response.json())
			.then(json => {
				// Do stuff with json
			});
	</code></pre>
	<details class="notes">
		Many functions in JS cannot return a result within a reasonable amount of time.
		For example, [`fetch()`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) sends an arbitrary HTTP request and reads the response. This can take a long time.
		To avoid blocking execution, we use *asynchronous* functions, which return a [*promise*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
		which will eventually have the value we want.
		In fact, using `fetch()` involves two promises: one for the response, and one for the JSON data.
	</details>
</article>

<article class="slide code-labels">
	<h1>Using Async and Await</h1>
	<pre><code>
		async function fetchUserData() {
			try {
			  const response = await fetch("https://api.github.com/users/giorgianicolaou");
			  const user = await response.json();
			  console.log("User data:", user);
		  
			  const reposResponse = await fetch(user.repos_url);
			  const repos = await reposResponse.json();
			  console.log("Repositories:", repos);
			} catch (error) {
			  console.error("Error:", error);
			}
		  }
		  
		  fetchUserData();		  
	</code></pre>
</article>

<footer class="slide" id="end"></footer>

</body>
</html>